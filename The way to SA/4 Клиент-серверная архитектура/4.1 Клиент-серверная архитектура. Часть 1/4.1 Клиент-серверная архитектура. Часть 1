
# Клиент серверная архитектура(КСА)

#КСА  Клиент серверная архитектура - это взаимодействие двух систем, где одна система выступает в роли Клиента, а другая в роли Сервера

#Клиент - роль системы, которой нужна информация и она делает запросы для получения информации на сервер.

#Сервер - роль системы, которая владеет информацией и отвечает на запросы Клиента.

Клиентом является устройство, с которым работает пользователь. Примеры:
1. ﻿﻿﻿ПК
2. ﻿﻿﻿Ноутбук
3. ﻿﻿﻿Телефон
4. Планшет

Сервером является компьютер, на котором хранится само приложение. Весь код, вся логика или данные (если это база данных). Примеры:
1. ﻿﻿﻿Сервер логики
2. ﻿﻿﻿Сервер Базы данных

==КСА определяет лишь общие принципы взаимодействия между компьютерами==, детали взаимодействия определяют различные протоколы.

#Протокол - набор правил по которым общаются клиент и сервер (например http)

---

# Уровни (слои) КСА

КСА состоит из 3-х уровней (слои):

**Уровень представления** - уровень на котором данные полученные клиентом преображаются в человекочитаемый вид и отображаются на интерфейсе клиента.

**Уровень бизнес-логики** - этот уровень координирует программу, обрабатывает команды, выполняет логические решения и вычисления, выполняет расчеты. Также перемещается и обрабатывает данные между двумя окружающими слоями.

**Уровень данных** - уровень на котором хранится информация и откуда она извлекается (базы данных). Информация из уровня данных отправляется в уровень бизнес-логики для обработки, и в конечном счете возвращается пользователю

![4.1.1 Слои кса](4.1.1%20Слои%20кса.png)


--- 

# Виды КСА

КСА бывает двух видов:

#ДвухзвеннаяКСА  – архитектура, в которой уровень представления находится на Клиенте, а уровень бизнес-логики и уровень данных находятся на Сервере. То есть и данные хранятся и логика выполняется на сервере.

![4.1.2 Двухзвенная КСА](4.1.2%20Двухзвенная%20КСА.png)


#определение 
#ТрехзвеннаяКСА –  архитектура, в которой уровень представления находится на Клиенте, уровень бизнес-логики находится на Сервере, а уровень данных находится на выделенной в отдельный сервер Базе данных

![4.1.3 Трехзвенная КСА](4.1.3%20Трехзвенная%20КСА.png)


## Описание слоев КСА

**Слой клиента** - Самый верхний уровень приложения с интерфейсом пользователя. Главная функция интерфейса - это передача задач и результатов понятных пользователю.

**Слой логики** - Этот слой координирует программу, обрабатывает команды, выполняет логические решения и вычисления, выполняет расчеты. Также перемещается и обрабатывает данные между двумя окружающими слоями.

**Слой данных** - Здесь хранится информация и извлекается из базы данных. Информация отправляется в логический слой для обработки, и в конечном счете возвращается пользователю

---
# Причины выделения 3-го звена в КСА

**Причины появления трехзвенной архитектуры**

Отделение слоя данных в полноценный третий слой произошло по многим причинам, но самая главная - это ==возросшая нагрузка на сервер.==

Во-первых, базы данных стали требовать много памяти и ==процессорного времени на обработку данных==. Поэтому их повсеместно стали выносить на отдельные сервера.

Бэкенд при возросшей нагрузке можно было легко дублировать и поднять десять копий одного сервера, а ==дублировать базу данных было нельзя== - база все еще оставалась единым и неделимым компонентом системы.

Во-вторых, базы данных стали умными — у них появилась собственная бизнес-логика. Они стали поддерживать хранимые процедуры, триггеры, собственные языки типа PL/SQL. И даже появились программисты, которые стали писать код, выполняемый внутри СУБД.

Всю логику, которая была не завязана на данные, выносили в бэкенд и параллельно запускали на десятках серверов. Все критично завязанное на данных оставалось внутри СУБД, но после этого проблемы масштабирования появились и на уровне данных, которые решали новыми методами:

#КластерБазыДанных - группа серверов БД, которые хранят одни и те же данные и синхронизируют их по определенному протоколу.

#Шардирование - данные дробятся на логические блоки и разносятся по разным серверам БД. Очень сложно поддерживать изменения БД при таком подходе.

#NoSQL - хранение данных в БД, которые построены для хранения огромного количества данных. Это часто даже и не базы, а специфические файловые хранилища. Очень бедный функционал по сравнению с реляционными базами данных.

#КэшированиеДанных -  Вместо простого кэша на уровне базы данных появились целые кеширующие СУБД, которые хранили результат только в памяти.

---

# Кластеризация серверов

#КластерCерверов (Server Cluster) –  это несколько серверов, объединенных в группу и работающих как единое приложение.

Данный подход позволяет существенно увеличить надежность и производительность системы.

#преимущества #кластеризация
Преимущества использования кластеризации:

1. Управлять произвольным количеством аппаратных средств с помощью одного программного модуля;
2. ﻿﻿﻿Добавлять и усовершенствовать программные и аппаратные ресурсы, без остановки системы и масштабных архитектурных преобразований;
3. ﻿﻿﻿Обеспечивать бесперебойную работу системы, при выходе из строя одного или нескольких серверов;
4. ﻿﻿﻿Синхронизировать данные между серверами - единицами кластера;
5. ﻿﻿Эффективно распределять клиентские запросы по серверам;
6. ﻿﻿﻿Использовать общую базу данных кластера.

Распределение нагрузки между серверами происходит с помощью балансировщика.

#БалансировщикНагрузки Балансировщик нагрузки (отдельное ПО на сервере или на уровне маршрутизатора) - принимает входящий сетевой трафик от клиента и, основываясь на некоторых критериях этого трафика, отправляет эти сообщения на один из нескольких серверов.

У клиента есть только адрес балансировка (URL)_ дальше он сам распределяет по серверам запросы, в зависимости от загрузки

![4.1.4 Кластеризация](4.1.4%20Кластеризация.png)

---
# Резервы и их виды

#ХолодныйРезерв Холодный резерв – для репликации и резервного копирования любых данных в удаленное облачное хранилище

#ТеплыйРезерв Теплый резерв – полнофункциональная или вспомогательная площадка на случай прекращения работоспособности основной площадки или временного расширения нагрузки

#ГорячийРезерв Горячий резерв – решение с максимальным уровнем отказоустойчивости информационных систем или отдельных решений.

---

## Холодный резерв

«Холодный» резерв простейшем виде может быть обычным резервным копированием с необходимой глубиной хранения.

ПРИМЕР: Офисная инфраструктура через site-to-site VPN подключается к облачной. Настраиваются правила резервного копирования (перечень ресурсов, периодичность, глубина и т. п.). В случае потери данных в офисе они будут гарантированно восстановлены из географически удаленного ЦОДа (в том числе в случае катастрофы).

![4.1.5 Холодный резерв](4.1.5%20Холодный%20резерв.png)

--- 

## Теплый резерв

«Теплый» резерв может быть организован на основе быстрого резервного копирования с минимально возможным временем потери и восстановления информации и состояния системы. Это может быть «горячий» резерв только части сервисов, например базы данных или иных систем в режиме репликации без активного использования вычислительных мощностей (процессоров и памяти). Важно решить, какую часть нагрузки должна обеспечивать резервная система и, если необходимо, возможное время развертывания резервной площадки на полную или частичную мощность.

![4.1.6 Теплый резерв](4.1.6%20Теплый%20резерв.png)

---
## Горячий резерв

«Горячий» резерв может совмещать максимальную отказоустойчивость, геораспределенность и балансировку нагрузки как на уровне приложений, так и на платформенном уровне: уровне операционных систем и систем хранения.

![4.1.6 Горячий резерв](4.1.6%20Горячий%20резерв.png)

---
# Виды клиентов

В среде компьютерной терминологии, понятие «клиент» означает определенное программное или аппаратное обеспечение, которое выполняет работу по взаимодействию с сервером для получения пользователем данных о выполненных системой действиях.

Клиент - очень важная составляющая системной архитектуры.

Простой пример клиента - это классический веб-браузер (на ПК или мобильном телефоне), способный выполнять передачу веб-запросов на веб-сервер, получая в ответ содержание необходимой веб-страницы. Все клиенты в клиент-серверной архитектуре условно делятся на два подтипа: толстые и тонкие.

Дополнительно есть архитектуры, которые могут объединять в себе «способности» тонких и толстых. Это гибридные

Итак, разберем каждый вид по отдельности.

## ПОНЯТИЕ ТОЛСТОГО КЛИЕНТА

#ТолстыйКлиент  Толстый клиент - клиент, выполняющий запрашиваемые со стороны пользователя манипуляции независимо от ведущего сервера. Основной сервер в такой вариации системной архитектуры может применяться как особое хранилище информации, обработка и конечное предоставление которых просто переносится на локальную машину пользователя.

Толстый клиент - это рабочая машина или ПК, которые функционируют на основе своей ОС и наполнены полноценным набором ПО для требуемых задач пользователя.

Преимущества толстых клиентов:

1. ﻿﻿﻿Большая функциональность;
2. ﻿﻿﻿Наличие многопользовательского режима;
3. ﻿﻿﻿Возможность работы в режиме оффлайн;
4. ﻿﻿﻿Мгновенное быстродействие;
5. ﻿﻿﻿Минимальная зависимость от сложных серверов.

Недостатки:

1. ﻿﻿﻿Все рабочие машины на постоянной основе нуждаются в техническом обслуживании;
2. ﻿﻿﻿Нужда в индивидуальном обновлении аппаратного ПО каждого клиента до уровня программного обеспечения, которое будет использоваться;
3. ﻿﻿﻿Массивные объемы дистрибутивов;
4. ﻿﻿﻿Полная зависимость от платформ, под которую данные клиенты были созданы.

## ПОНЯТИЕ ТОНКОГО КЛИЕНТА

#ТонкийКлиент - вид клиента, который может переносить выполнение задач по обработке информации на сервер, не применяя свои мощности по вычислению для их внедрения. Все вычислительные ресурсы подобного клиента максимально ограничены, важно, чтобы их хватало для старта нужного сетевого ПО, применяя, к примеру, веб-интерфейс.

Одним из наиболее распространенных примеров такого типа клиента считается ПК с заранее установленным веб-браузером, который применяется для функционирования с веб-програмами.

Характерная черта тонких клиентов - применение терминального режима функционирования. В такой ситуации, терминальный сервер применяется для процесса отправки и получения информации пользователя, что и является базовым отличием от процесса независимой обработки информации в толстых клиентах.

Плюсы тонкого клиента:

1. ﻿﻿﻿Минимальное аппаратное обслуживание;
2. ﻿﻿﻿Низкий риск возникновения неисправности;
3. ﻿﻿﻿Минимальные технические требования к аппаратному оборудованию.

Недостатки:

1. ﻿﻿﻿При сбое на сервере «пострадают» все подключенные пользователи;
2. ﻿﻿﻿Нет возможности работать без активного подключения к сети;
3. ﻿﻿﻿При взаимодействии с большим массивом данных может снижаться объем производительности основного сервера.

## КАКАЯ МЕЖДУ НИМИ РАЗНИЦА?

Базовые отличия между ними - это варианты обработки данных.

Толстые клиенты работают с информацией на основе собственных аппаратных и программных возможностей, в то же время тонкие применяют ПО центрального сервера только чтобы обработать данные, предоставляя системе лишь требуемый графический интерфейс для выполнения работы пользователем. Это значит, что в роли тонких клиентов иногда мы можем увидеть устаревшие или не очень производительные ПК.

ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ ИЗ ПОВСЕДНЕВНОЙ ПРАКТИКИ ПОЛЬЗОВАТЕЛЕЙ

Все пользователи глобальной сети Интернет, так или иначе, сталкиваются как с толстыми, так и с тонкими клиентами.

С технической стороны, толстым клиентом может считаться локальная машина, которую пользователь применяет для внедрения своих намеченных целей.

Тонкий клиент может представлять собой отдельную рабочую станцию. Подобные тонкие клиенты могут быть весьма компактными, применять пассивное охлаждение. Порой, тонких клиентов используют в роли офисных локальных машин.

Если взглянуть с программной точки зрения, понятными примерами толстых клиентов можно считать программы для совместной деятельности, если они изначально установлены на определенные вычислительные устройства.

Например: Yahoo Messenger, Office 365, Microsoft Outlook.


# Вопросы
1. Как реплицируются данные для горячего резерва. То-есть балансировщик получает запрос, отправляет его на оба приложения, но игнорирует ответ от воторого, в случае работоспособности первого?
2. Можно ли привести пример плохой оптимизации работы в случае тонкого клиента, если архитектура приложения вынесла огромную логику на js получаемого клиентом(Наука 0+ корзина на фронте)